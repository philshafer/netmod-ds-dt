This represents the lifecycle of data within a device, and I've
drawn "====" boxes as "data" with "----" boxes as the operations
that are performed on that data to move it to the next step in the
lifecycle.  Hopefully that's clear.  Notes follow.

We wanted meaningless names for the phases, so we're using phonetic
alphabet names/codes.  For example, "zulu" and "yankee" are the last
two phases.

-------------------

      +--[hotel-delta]-----------------------------
      | Human-based Config (potentially empty) [1]
      | + System controlled (explicit) data
      +------------------------------
       /
+==[hotel]==+
|           |
+===========+
       \
      +--[india-delta]----------------------------
      | Zero-Touch Provisioning (ZTP)
      +------------------------------
       /
+==[india]==+
|           |
+===========+
       \
      +--[juliette-delta]----------------------------
      | NETCONF (<edit-config>)
      | (Syntactic validation) [2]
      +------------------------------
       /
+=[juliette]+
|           |
+===========+
       \
      +--[kilo-delta]----------------------------
      | <commit-config> [4]
      +------------------------------
       /
+==[kilo]===+
|           |
+===========+
       \
      +--[lima-delta]---------------------------
      | - remove inactive
      | + expand any template/group mechanism [3]
      | + add system-controlled implicit data
      +------------------------------
       /
+==[lima]===+
|           |
+===========+
       \
      +--[mike-delta]----------------------------
      | Semantic validation
      | + commit-time system-controlled data
      +------------------------------
       /
+==[mike]===+
| post validation [6]
| aka "intended configuration" [5]
+===========+
       \
      +--[november-delta----------------
      | - remove data for missing hardware ("ephemeral interfaces" [7])
      +------------------------------
       /
+==[november]=+
| system adjusted aka "applied" [8]
+=============+
       \
      +--[oscar-delta]----------------------------
      | merge ephemeral database
      +------------------------------
       /
+==[oscar]==+
| [9]   |
+===========+
       \
      +--[papa-delta]----------------------------
      | add data learned from DHCP, radius, 802.1x, etc
      +------------------------------
       /
+==[papa]===+
| "complete instructions" [10]
+===========+
       \
      +--[yankee-delta]----------------------------
      | replace config=true nodes with "current" values  [11]
      +------------------------------
       /
+==[yankee]=+
|           |
+===========+
       \
      +--[zulu-delta]---------------------------
      | add config=false" nodes
      +------------------------------
       /
+==[zulu]===+
| aka "opstate"
+===========+


------------------------------------------------------------

Notes:

[1] Called out to allow us to think about how human-contributed config
should have priority against automation-based data.

[2] Edit-config payloads are syntactically checked during processing.

[3] Such mechanisms are completely outside the spec of NETCONF, but we
in dealing with the "real world", we must admit their existence and
fit them into our world view.

[4] While <commit-config> is only an operation if #candidate is
supported, we can view it as an implicit operation at the end of each
<edit-config> operation on the running datastore.

[5] This datastore contains the "intended" configuration that the user
intends to be used.  This remains a bit of a "Rorschach" term, but
folks seem to stick with it regardless.

[6] The "post validation" datastore represents the contents of
"running" after a <commit-config> operation (if #candidate) or an
<edit-config> operation on the running datastore.

[7] "ephemeral interfaces" is the term we've used for these sort of
"pre-provisioned" interface configurations in the past, thought this
term becomes overloaded with the introduction of "ephemeral
datastores".

[8] Again, the "applied" configuration term is a bit fuzzy, but seems
too sticky to remove.  "system adjusted" has less fuzz, but also less
curb appeal.

[9] There was no real consensus on the need to distinguish data gained
from the ephemeral database from that gained from mechanisms like
DHCP, etc.  But IMHO the fact that ephemeral databases are "our's" and
the rest are not means that we need to call them out specifically.

[10] New term meant to represent that outcome of all the mechanisms
that gives "instructions" to the device.

[11] This description, while accurate, is not completely clear.  As we
write all this up, it might be better to view this as a completely
distinct datastore rather than a set of operations performed on a
single stream of data.

----------------------

So we need to perform the following tasks:

(a) converge on a world view
(b) agree on terminology
(c) decide which data phases need to be externally visible
(d) create a mechanism to allow devices to describe which of those
    can be accessed on this particular device
(e) write it up
